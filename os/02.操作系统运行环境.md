# 操作系统运行环境

## 处理器状态

### 两类寄存器
- 用户可见寄存器：
  高级语言编译器通过优化算法分配之，以减少程序访问内存次数
- 控制和状态寄存器：
  该类寄存器常用于控制处理器的操作，通常由操作系统代码使用。
  常见的有 PC，IR，PSW
  PSW：程序状态字，记录处理器的运行状态如条件码、模式、控制位等信息。
  在PSW寄存器中专门设置一位，根据程序**对资源和指令的使用权限**而设置不同的处理器状态。

### 两种处理器状态
  - 内核态：运行操作系统程序
  - 用户态：运行用户程序

> 处理器的状态转换  
- 用户态 -> 内核态 中断、异常、陷入指令（如 int, trap, syscall, sysenter/sysexit）  
- 内核态 -> 用户态 设置PSW  


## 中断与异常机制

### 常见中断与异常
中断举例：I/O中断，时钟中断，硬件中断  
异常举例：系统调用，页故障/页错误，保护性异常，断点指令，其他程序性异常  

### 中断机制的工作原理
若有中断，中断硬件将该中断触发器内容按规定编码送入PSW的相应位，称为中断码，通过查中断向量表引出中断处理程序。  


## 系统调用

### 概念
系统调用是除异常和中断外，操作系统提供给编程人员进入内核的唯一接口。每个操作系统都提供几百种系统调用（进程控制，进程通信，文件使用，目录操作，设备管理，信息维护等）。

> 与库函数的关系  
应用程序->系统调用；应用程序->C函数库/API接口->系统调用。

### 系统调用执行过程
当CPU执行到特殊的陷入指令时：
1. 中断/异常机制：硬件保护现场；通过查中断向量表把控制权转给系统调用总入口程序
2. 系统调用总入口程序：保存现场；将参数保存在内核堆栈里；通过查系统调用表把控制权转给相应的系统调用处理例程或内核函数
3. 执行系统调用例程
4. 恢复现场，返回用户程序

> 例子  
用 int 80h 调用 第4号 系统调用 （即 write), 将 "hello world" 打印到标准输出  
(我用的是 at&t 风格的汇编，这是 gcc 默认使用的格式）  
```
.data
hello:
        .string "Hello world\n"
.globl main
main:
        movl $4, %eax
        movl $1, %ebx
        movl $hello, %ecx
        movl $12, %edx
        int $0x80
        ret 
```
把上面的内容存入 xxx.s ，然后用 gcc xxx.s -o xxx 即可编译出可执行文件。

