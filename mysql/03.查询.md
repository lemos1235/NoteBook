# 查询性能优化

## 为什么查询会变慢
如果把查询看作是一个任务，那么它由一系列子任务组成，每个子任务都会消耗一定的时间。如果要优化查询，实际上要优化子任务，要么消除其中一些子任务，要么减少子任务的执行次数，要么让子任务运行得更快。

## 慢查询基础：优化数据访问
查询性能地下最基本的原因是访问的数据太多。

### 是否请求了不需要的数据
略

### MySQL 是否在扫描额外的记录
查看查询为了返回结果是否扫描了过多的数据。对于MySQL，衡量查询开销的三个指标如下：
- 响应时间
- 扫描的行数
- 返回的行数

#### 响应时间
响应时间=服务时间（真正花了多少时间）+ 排队时间

#### 扫描的行数与访问类型
在评估查询开销的时候，需要考虑以下从表中查找某一行数据的成本（扫描的行数）。

一般 MySQL 能够使用如下三种方式应用 WHERE 条件，从好到坏依次为：
* 在索引中使用 WHERE 条件来过滤不匹配的记录。这是在存储引擎层完成的。
* 使用索引覆盖，直接从索引中过滤不需要的记录并返回。这是在 MySQL 服务器层完成的，但无须再回表查询记录。
* 从数据表中返回数据，然后过滤不满足条件的记录（在Extra 列中出现 Using where）。这是在 MySQL 服务器层完成，MySQL 需要先从数据表读取记录然后过滤。



### 重构查询
将查询换一种写法让其返回一样的结果，但是性能更好。

#### 一个复杂查询还是多个简单查询
略

#### 切分查询
将大查询切分成小查询，每个查询功能一样，只完成一小部分，每次只返回一小部分查询结果。

举例：将一个大的 DELETE 语句切分成多个较小的查询可以尽可能小地影响 MySQL 性能。

#### 分解关联子查询
- 将查询分解，执行单个查询可以减少锁的竞争
- 在应用层做关联，可以更容易对数据库进行拆分。
- 查询性能本身效率也可能会有所提升。比如使用 IN (ids...) 代替关联查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的关联要更高效。
- 在应用层实现了哈希关联，而不是使用 MySQL 的嵌套循环关联。某些场景下哈希关联的效率要高很多。



### 查询执行的基础

#### MySQL 客户端/服务端通信协议

MySQL 客户端和服务器之间的通信协议是“半双工”的，这意味着，在任何一个时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发生。

客户端用一个单独的数据包将查询传给服务器。当查询的数据很长的时候，参数 max_allowed_packet 就特别重要了。

当服务器开始响应客户端请求时，客户端必须完整地接收整个返回结果。因此在必要的时候一定要在查询中加上 LIMIT 限制。


#### 查询状态
对于一个 MySQL 连接，或者说一个线程，任何时刻都有一个状态。该状态表示了 MySQL 当前正在做什么。可以使用 SHOW FULL PROCESSLIST 命令。在一个查询的生命周期中，状态会变化很多次。下面将这些状态列出来

**Sleep**  
线程正在等待客户端发送新的请求

**Query**  
线程正在执行查询或正在将结果发送给客户端

**Locked**  
在 MySQL 服务器层，该线程正在等待表锁。在存储引擎级别实现的锁，例如 InnoDB 的行锁，并不会体现在线程状态中。对于 MyISAM 来说这是应该比较典型的状态。

**Analyzing and statistics**  
线程正在收集存储引擎的统计信息，并生成执行计划。

**Copying to tmp table [on disk]**  
线程正在执行查询，并且将结果集都复制到一个临时表，这种状态要么是在做 GROUP BY 操作，要么是文件排序操作，或者是 UNION 操作。如果这个状态后面还有应该“on disk”标记，那表示 MySQL 正在将一个内存临时表放到磁盘上。

**Sorting result**  
线程正在对结果集进行排序。

**Sending data**  
这表示多种情况：线程可能在多个状态之间传送数据，或者在生成结果集，或者在向客户端返回数据。


#### 查询缓存
略


#### 查询优化处理
##### 语法解析器和预处理
解析器负责将SQL解析，生成解析树。它将验证是否使用错误的关键字，使用关键字的顺序是否正确，引号是否前后匹配。
预处理器负责检查数据表和数据列是否存在，解析名字和别名是否有歧义，验证权限。

##### 查询优化器
略
